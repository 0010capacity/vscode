# ---------------------------------------------------------------------------------------------
#   Copyright (c) Microsoft Corporation. All rights reserved.
#   Licensed under the MIT License. See License.txt in the project root for license information.
# ---------------------------------------------------------------------------------------------

# Need this variable as long as we support PS v2
$ModuleBasePath = Split-Path $MyInvocation.MyCommand.Path -Parent

# Store error records generated by stderr output when invoking an executable
# This can be accessed from the user's session by executing:
# PS> $m = Get-Module posh-git
# PS> & $m Get-Variable invokeErrors -ValueOnly
$invokeErrors = New-Object System.Collections.ArrayList 256

# General Utility Functions

function Invoke-NullCoalescing {
	$result = $null
	foreach ($arg in $args) {
		if ($arg -is [ScriptBlock]) {
			$result = & $arg
		}
		else {
			$result = $arg
		}
		if ($result) { break }
	}
	$result
}

Set-Alias ?? Invoke-NullCoalescing -Force

function Invoke-Utf8ConsoleCommand([ScriptBlock]$cmd) {
	$currentEncoding = [Console]::OutputEncoding
	$errorCount = $global:Error.Count
	try {
		# A native executable that writes to stderr AND has its stderr redirected will generate non-terminating
		# error records if the user has set $ErrorActionPreference to Stop. Override that value in this scope.
		$ErrorActionPreference = 'Continue'

		try { [Console]::OutputEncoding = [Text.Encoding]::UTF8 } catch [System.IO.IOException] {}
		& $cmd
	}
	finally {
		try { [Console]::OutputEncoding = $currentEncoding } catch [System.IO.IOException] {}

		# Clear out stderr output that was added to the $Error collection, putting those errors in a module variable
		if ($global:Error.Count -gt $errorCount) {
			$numNewErrors = $global:Error.Count - $errorCount
			$invokeErrors.InsertRange(0, $global:Error.GetRange(0, $numNewErrors))
			if ($invokeErrors.Count -gt 256) {
				$invokeErrors.RemoveRange(256, ($invokeErrors.Count - 256))
			}
			$global:Error.RemoveRange(0, $numNewErrors)
		}
	}
}

function Test-Administrator {
	# PowerShell 5.x only runs on Windows so use .NET types to determine isAdminProcess
	# Or if we are on v6 or higher, check the $IsWindows pre-defined variable.
	if (($PSVersionTable.PSVersion.Major -le 5) -or $IsWindows) {
		$currentUser = [Security.Principal.WindowsPrincipal]([Security.Principal.WindowsIdentity]::GetCurrent())
		return $currentUser.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
	}

	# Must be Linux or OSX, so use the id util. Root has userid of 0.
	return 0 -eq (id -u)
}

<#
.SYNOPSIS
	Configures your PowerShell profile (startup) script to import the posh-git
	module when PowerShell starts.
.DESCRIPTION
	Checks if your PowerShell profile script is not already importing posh-git
	and if not, adds a command to import the posh-git module. This will cause
	PowerShell to load posh-git whenever PowerShell starts.
.PARAMETER AllHosts
	By default, this command modifies the CurrentUserCurrentHost profile
	script.  By specifying the AllHosts switch, the command updates the
	CurrentUserAllHosts profile (or AllUsersAllHosts, given -AllUsers).
.PARAMETER AllUsers
	By default, this command modifies the CurrentUserCurrentHost profile
	script.  By specifying the AllUsers switch, the command updates the
	AllUsersCurrentHost profile (or AllUsersAllHosts, given -AllHosts).
	Requires elevated permissions.
.PARAMETER Force
	Do not check if the specified profile script is already importing
	posh-git. Just add Import-Module posh-git command.
.EXAMPLE
	PS C:\> Add-PoshGitToProfile
	Updates your profile script for the current PowerShell host to import the
	posh-git module when the current PowerShell host starts.
.EXAMPLE
	PS C:\> Add-PoshGitToProfile -AllHosts
	Updates your profile script for all PowerShell hosts to import the posh-git
	module whenever any PowerShell host starts.
.INPUTS
	None.
.OUTPUTS
	None.
#>
function Add-PoshGitToProfile {
	[CmdletBinding(SupportsShouldProcess)]
	param(
		[Parameter()]
		[switch]
		$AllHosts,

		[Parameter()]
		[switch]
		$AllUsers,

		[Parameter()]
		[switch]
		$Force,

		[Parameter(ValueFromRemainingArguments)]
		[psobject[]]
		$TestParams
	)

	if ($AllUsers -and !(Test-Administrator)) {
		throw 'Adding posh-git to an AllUsers profile requires an elevated host.'
	}

	$underTest = $false

	$profileName = $(if ($AllUsers) { 'AllUsers' } else { 'CurrentUser' }) `
		+ $(if ($AllHosts) { 'AllHosts' } else { 'CurrentHost' })
	Write-Verbose "`$profileName = '$profileName'"

	$profilePath = $PROFILE.$profileName
	Write-Verbose "`$profilePath = '$profilePath'"

	# Under test, we override some variables using $args as a backdoor.
	if (($TestParams.Count -gt 0) -and ($TestParams[0] -is [string])) {
		$profilePath = [string]$TestParams[0]
		$underTest = $true
		if ($TestParams.Count -gt 1) {
			$ModuleBasePath = [string]$TestParams[1]
		}
	}

	if (!$profilePath) { $profilePath = $PROFILE }

	if (!$Force) {
		# Search the user's profiles to see if any are using posh-git already, there is an extra search
		# ($profilePath) taking place to accommodate the Pester tests.
		$importedInProfile = Test-PoshGitImportedInScript $profilePath
		if (!$importedInProfile -and !$underTest) {
			$importedInProfile = Test-PoshGitImportedInScript $PROFILE
		}
		if (!$importedInProfile -and !$underTest) {
			$importedInProfile = Test-PoshGitImportedInScript $PROFILE.CurrentUserCurrentHost
		}
		if (!$importedInProfile -and !$underTest) {
			$importedInProfile = Test-PoshGitImportedInScript $PROFILE.CurrentUserAllHosts
		}
		if (!$importedInProfile -and !$underTest) {
			$importedInProfile = Test-PoshGitImportedInScript $PROFILE.AllUsersCurrentHost
		}
		if (!$importedInProfile -and !$underTest) {
			$importedInProfile = Test-PoshGitImportedInScript $PROFILE.AllUsersAllHosts
		}

		if ($importedInProfile) {
			Write-Warning "Skipping add of posh-git import to file '$profilePath'."
			Write-Warning "posh-git appears to already be imported in one of your profile scripts."
			Write-Warning "If you want to force the add, use the -Force parameter."
			return
		}
	}

	if (!$profilePath) {
		Write-Warning "Skipping add of posh-git import to profile; no profile found."
		Write-Verbose "`$PROFILE			  = '$PROFILE'"
		Write-Verbose "CurrentUserCurrentHost = '$($PROFILE.CurrentUserCurrentHost)'"
		Write-Verbose "CurrentUserAllHosts	= '$($PROFILE.CurrentUserAllHosts)'"
		Write-Verbose "AllUsersCurrentHost	= '$($PROFILE.AllUsersCurrentHost)'"
		Write-Verbose "AllUsersAllHosts	   = '$($PROFILE.AllUsersAllHosts)'"
		return
	}

	# If the profile script exists and is signed, then we should not modify it
	if (Test-Path -LiteralPath $profilePath) {
		if (!(Get-Command Get-AuthenticodeSignature -ErrorAction SilentlyContinue))
		{
			Write-Verbose "Platform doesn't support script signing, skipping test for signed profile."
		}
		else {
			$sig = Get-AuthenticodeSignature $profilePath
			if ($null -ne $sig.SignerCertificate) {
				Write-Warning "Skipping add of posh-git import to profile; '$profilePath' appears to be signed."
				Write-Warning "Add the command 'Import-Module posh-git' to your profile and resign it."
				return
			}
		}
	}

	# Check if the location of this module file is in the PSModulePath
	if (Test-InPSModulePath $ModuleBasePath) {
		$profileContent = "`nImport-Module posh-git"
	}
	else {
		$modulePath = Join-Path $ModuleBasePath posh-git.psd1
		$profileContent = "`nImport-Module '$modulePath'"
	}

	# Make sure the PowerShell profile directory exists
	$profileDir = Split-Path $profilePath -Parent
	if (!(Test-Path -LiteralPath $profileDir)) {
		if ($PSCmdlet.ShouldProcess($profileDir, "Create current user PowerShell profile directory")) {
			New-Item $profileDir -ItemType Directory -Force -Verbose:$VerbosePreference > $null
		}
	}

	if ($PSCmdlet.ShouldProcess($profilePath, "Add 'Import-Module posh-git' to profile")) {
		Add-Content -LiteralPath $profilePath -Value $profileContent -Encoding UTF8
	}
}

<#
.SYNOPSIS
	Modifies your PowerShell profile (startup) script so that it does not import
	the posh-git module when PowerShell starts.
.DESCRIPTION
	Checks if your PowerShell profile script is importing posh-git and if it does,
	removes the command to import the posh-git module. This will cause PowerShell
	to no longer load posh-git whenever PowerShell starts.
.PARAMETER AllHosts
	By default, this command modifies the CurrentUserCurrentHost profile
	script.  By specifying the AllHosts switch, the command updates the
	CurrentUserAllHosts profile (or AllUsersAllHosts, given -AllUsers).
.PARAMETER AllUsers
	By default, this command modifies the CurrentUserCurrentHost profile
	script.  By specifying the AllUsers switch, the command updates the
	AllUsersCurrentHost profile (or AllUsersAllHosts, given -AllHosts).
	Requires elevated permissions.
.EXAMPLE
	PS C:\> Remove-PoshGitFromProfile
	Updates your profile script for the current PowerShell host to stop importing
	the posh-git module when the current PowerShell host starts.
.EXAMPLE
	PS C:\> Remove-PoshGitFromProfile -AllHosts
	Updates your profile script for all PowerShell hosts to no longer import the
	posh-git module whenever any PowerShell host starts.
.INPUTS
	None.
.OUTPUTS
	None.
#>
function Remove-PoshGitFromProfile {
	[CmdletBinding(SupportsShouldProcess)]
	param(
		[Parameter()]
		[switch]
		$AllHosts,

		[Parameter()]
		[switch]
		$AllUsers,

		[Parameter(ValueFromRemainingArguments)]
		[psobject[]]
		$TestParams
	)

	if ($AllUsers -and !(Test-Administrator)) {
		throw 'Removing posh-git from an AllUsers profile requires an elevated host.'
	}

	$underTest = $false

	$profileName = $(if ($AllUsers) { 'AllUsers' } else { 'CurrentUser' }) `
		+ $(if ($AllHosts) { 'AllHosts' } else { 'CurrentHost' })
	Write-Verbose "`$profileName = '$profileName'"

	$profilePath = $PROFILE.$profileName
	Write-Verbose "`$profilePath = '$profilePath'"

	# Under test, we override some variables using $args as a backdoor.
	if (($TestParams.Count -gt 0) -and ($TestParams[0] -is [string])) {
		$profilePath = [string]$TestParams[0]
		$underTest = $true
		if ($TestParams.Count -gt 1) {
			$ModuleBasePath = [string]$TestParams[1]
		}
	}

	if (!$profilePath) { $profilePath = $PROFILE }

	if (!$profilePath) {
		Write-Warning "Skipping removal of posh-git import from profile; no profile found."
		Write-Verbose "`$PROFILE			  = '$PROFILE'"
		Write-Verbose "CurrentUserCurrentHost = '$($PROFILE.CurrentUserCurrentHost)'"
		Write-Verbose "CurrentUserAllHosts	= '$($PROFILE.CurrentUserAllHosts)'"
		Write-Verbose "AllUsersCurrentHost	= '$($PROFILE.AllUsersCurrentHost)'"
		Write-Verbose "AllUsersAllHosts	   = '$($PROFILE.AllUsersAllHosts)'"
		return
	}

	if (Test-Path -LiteralPath $profilePath) {
		# If the profile script exists and is signed, then we should not modify it
		if (!(Get-Command Get-AuthenticodeSignature -ErrorAction SilentlyContinue))
		{
			Write-Verbose "Platform doesn't support script signing, skipping test for signed profile."
		}
		else {
			$sig = Get-AuthenticodeSignature $profilePath
			if ($null -ne $sig.SignerCertificate) {
				Write-Warning "Skipping removal of posh-git import from profile; '$profilePath' appears to be signed."
				Write-Warning "Remove the command 'Import-Module posh-git' from your profile and resign it."
				return
			}
		}

		$oldProfile = @(Get-Content $profilePath)
		$oldProfileEncoding = Get-FileEncoding $profilePath

		$newProfile = @()
		foreach($line in $oldProfile) {
			if ($line -like '*PoshGitPrompt*') { continue; }
			if ($line -like '*Load posh-git example profile*') { continue; }

			if($line -like '. *posh-git*profile.example.ps1*') {
				continue;
			}
			if($line -like 'Import-Module *\posh-git.psd1*') {
				continue;
			}
			$newProfile += $line
		}
		Set-Content -path $profilePath -value $newProfile -Force -Encoding $oldProfileEncoding
	}
}

<#
.SYNOPSIS
	Gets the file encoding of the specified file.
.DESCRIPTION
	Gets the file encoding of the specified file.
.PARAMETER Path
	Path to the file to check.  The file must exist.
.EXAMPLE
	PS C:\> Get-FileEncoding $profile
	Get's the file encoding of the profile file.
.INPUTS
	None.
.OUTPUTS
	[System.String]
.NOTES
	Adapted from http://www.west-wind.com/Weblog/posts/197245.aspx
#>
function Get-FileEncoding($Path) {
	if ($PSVersionTable.PSVersion.Major -ge 6) {
		$bytes = [byte[]](Get-Content $Path -AsByteStream -ReadCount 4 -TotalCount 4)
	}
	else {
		$bytes = [byte[]](Get-Content $Path -Encoding byte -ReadCount 4 -TotalCount 4)
	}

	if (!$bytes) { return 'utf8' }

	switch -regex ('{0:x2}{1:x2}{2:x2}{3:x2}' -f $bytes[0],$bytes[1],$bytes[2],$bytes[3]) {
		'^efbbbf'   { return 'utf8' }
		'^2b2f76'   { return 'utf7' }
		'^fffe'	 { return 'unicode' }
		'^feff'	 { return 'bigendianunicode' }
		'^0000feff' { return 'utf32' }
		default	 { return 'ascii' }
	}
}

<#
.SYNOPSIS
	Gets a StringComparison enum value appropriate for comparing paths on the OS platform.
.DESCRIPTION
	Gets a StringComparison enum value appropriate for comparing paths on the OS platform.
.EXAMPLE
	PS C:\> $pathStringComparison = Get-PathStringComparison
.INPUTS
	None
.OUTPUTS
	[System.StringComparison]
#>
function Get-PathStringComparison {
	# File system paths are case-sensitive on Linux and case-insensitive on Windows and macOS
	if (($PSVersionTable.PSVersion.Major -ge 6) -and $IsLinux) {
		[System.StringComparison]::Ordinal
	}
	else {
		[System.StringComparison]::OrdinalIgnoreCase
	}
}

function Get-PromptPath {
	$settings = $global:GitPromptSettings
	$stringComparison = Get-PathStringComparison

	# A UNC path has no drive so it's better to use the ProviderPath e.g. "\\server\share".
	# However for any path with a drive defined, it's better to use the Path property.
	# In this case, ProviderPath is "\LocalMachine\My"" whereas Path is "Cert:\LocalMachine\My".
	# The latter is more desirable.
	$pathInfo = $ExecutionContext.SessionState.Path.CurrentLocation
	$currentPath = if ($pathInfo.Drive) { $pathInfo.Path } else { $pathInfo.ProviderPath }
	if (!$settings -or !$currentPath) {
		return $currentPath
	}

	$abbrevHomeDir = $settings.DefaultPromptAbbreviateHomeDirectory
	$abbrevGitDir = $settings.DefaultPromptAbbreviateGitDirectory

	# Look up the git root
	if ($abbrevGitDir) {
		$gitPath = Get-GitDirectory
		# Up one level from `.git`
		if ($gitPath) { $gitPath = Split-Path $gitPath -Parent }
	}

	# Abbreviate path under a git repository as "<repo-name>:<relative-path>"
	if ($abbrevGitDir -and $gitPath -and $currentPath.StartsWith($gitPath, $stringComparison)) {
		$gitName = Split-Path $gitPath -Leaf
		$relPath = if ($currentPath -eq $gitPath) { "" } else { $currentPath.SubString($gitPath.Length + 1) }
		$currentPath = "$gitName`:$relPath"
	}
	# Abbreviate path under the user's home dir as "~<relative-path>"
	elseif ($abbrevHomeDir -and $currentPath.StartsWith($Home, $stringComparison)) {
		$currentPath = "~" + $currentPath.SubString($Home.Length)
	}

	return $currentPath
}

<#
.SYNOPSIS
	Gets a string with current machine name and user name when connected with SSH
.PARAMETER Format
	Format string to use for displaying machine name ({0}) and user name ({1}).
	Default: "[{1}@{0}]: ", i.e. "[user@machine]: "
.INPUTS
	None
.OUTPUTS
	[String]
#>
function Get-PromptConnectionInfo($Format = '[{1}@{0}]: ') {
	if ($GitPromptSettings -and (Test-Path Env:SSH_CONNECTION)) {
		$MachineName = [System.Environment]::MachineName
		$UserName = [System.Environment]::UserName
		$Format -f $MachineName,$UserName
	}
}

function Get-PSModulePath {
	$modulePaths = $Env:PSModulePath -split ';'
	$modulePaths
}

function Test-InPSModulePath {
	param (
		[Parameter(Position=0, Mandatory=$true)]
		[ValidateNotNull()]
		[string]
		$Path
	)

	$modulePaths = Get-PSModulePath
	if (!$modulePaths) { return $false }

	$pathStringComparison = Get-PathStringComparison
	$Path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)
	$inModulePath = @($modulePaths | Where-Object { $Path.StartsWith($_.TrimEnd([System.IO.Path]::DirectorySeparatorChar), $pathStringComparison) }).Count -gt 0

	if ($inModulePath -and ('src' -eq (Split-Path $Path -Leaf))) {
		Write-Warning 'posh-git repository structure is incompatible with %PSModulePath%.'
		Write-Warning 'Importing with absolute path instead.'
		return $false
	}

	$inModulePath
}

function Test-PoshGitImportedInScript {
	param (
		[Parameter(Position=0)]
		[string]
		$Path
	)

	if (!$Path -or !(Test-Path -LiteralPath $Path)) {
		return $false
	}

	$match = (@(Get-Content $Path -ErrorAction SilentlyContinue) -match 'posh-git').Count -gt 0
	if ($match) { Write-Verbose "posh-git found in '$Path'" }
	$match
}

function dbg($Message, [Diagnostics.Stopwatch]$Stopwatch) {
	if ($Stopwatch) {
		Write-Verbose ('{0:00000}:{1}' -f $Stopwatch.ElapsedMilliseconds,$Message) -Verbose # -ForegroundColor Yellow
	}
}











# Inspired by Mark Embling
# http://www.markembling.info/view/my-ideal-powershell-prompt-with-git-integration

<#
.SYNOPSIS
	Gets the path to the current repository's .git dir.
.DESCRIPTION
	Gets the path to the current repository's .git dir.  Or if the repository
	is a bare repository, the root directory of the bare repository.
.EXAMPLE
	PS C:\GitHub\posh-git\tests> Get-GitDirectory
	Returns C:\GitHub\posh-git\.git
.INPUTS
	None.
.OUTPUTS
	System.String
#>
function Get-GitDirectory {
	$pathInfo = Microsoft.PowerShell.Management\Get-Location
	if (!$pathInfo -or ($pathInfo.Provider.Name -ne 'FileSystem')) {
		$null
	}
	elseif ($Env:GIT_DIR) {
		$Env:GIT_DIR -replace '\\|/', [System.IO.Path]::DirectorySeparatorChar
	}
	else {
		$currentDir = Get-Item -LiteralPath $pathInfo -Force
		while ($currentDir) {
			$gitDirPath = Join-Path $currentDir.FullName .git
			if (Test-Path -LiteralPath $gitDirPath -PathType Container) {
				return $gitDirPath
			}

			# Handle the worktree case where .git is a file
			if (Test-Path -LiteralPath $gitDirPath -PathType Leaf) {
				$gitDirPath = Invoke-Utf8ConsoleCommand { git rev-parse --git-dir 2>$null }
				if ($gitDirPath) {
					return $gitDirPath
				}
			}

			$headPath = Join-Path $currentDir.FullName HEAD
			if (Test-Path -LiteralPath $headPath -PathType Leaf) {
				$refsPath = Join-Path $currentDir.FullName refs
				$objsPath = Join-Path $currentDir.FullName objects
				if ((Test-Path -LiteralPath $refsPath -PathType Container) -and
					(Test-Path -LiteralPath $objsPath -PathType Container)) {

					$bareDir = Invoke-Utf8ConsoleCommand { git rev-parse --git-dir 2>$null }
					if ($bareDir -and (Test-Path -LiteralPath $bareDir -PathType Container)) {
						$resolvedBareDir = (Resolve-Path $bareDir).Path
						return $resolvedBareDir
					}
				}
			}

			$currentDir = $currentDir.Parent
		}
	}
}

function Get-GitBranch($branch = $null, $gitDir = $(Get-GitDirectory), [switch]$isDotGitOrBare, [Diagnostics.Stopwatch]$sw) {
	if (!$gitDir) { return }

	Invoke-Utf8ConsoleCommand {
		dbg 'Finding branch' $sw
		$r = ''; $b = ''; $c = ''
		$step = ''; $total = ''
		if (Test-Path $gitDir/rebase-merge) {
			dbg 'Found rebase-merge' $sw
			if (Test-Path $gitDir/rebase-merge/interactive) {
				dbg 'Found rebase-merge/interactive' $sw
				$r = '|REBASE-i'
			}
			else {
				$r = '|REBASE-m'
			}
			$b = "$(Get-Content $gitDir/rebase-merge/head-name)"
			$step = "$(Get-Content $gitDir/rebase-merge/msgnum)"
			$total = "$(Get-Content $gitDir/rebase-merge/end)"
		}
		else {
			if (Test-Path $gitDir/rebase-apply) {
				dbg 'Found rebase-apply' $sw
				$step = "$(Get-Content $gitDir/rebase-apply/next)"
				$total = "$(Get-Content $gitDir/rebase-apply/last)"

				if (Test-Path $gitDir/rebase-apply/rebasing) {
					dbg 'Found rebase-apply/rebasing' $sw
					$r = '|REBASE'
				}
				elseif (Test-Path $gitDir/rebase-apply/applying) {
					dbg 'Found rebase-apply/applying' $sw
					$r = '|AM'
				}
				else {
					$r = '|AM/REBASE'
				}
			}
			elseif (Test-Path $gitDir/MERGE_HEAD) {
				dbg 'Found MERGE_HEAD' $sw
				$r = '|MERGING'
			}
			elseif (Test-Path $gitDir/CHERRY_PICK_HEAD) {
				dbg 'Found CHERRY_PICK_HEAD' $sw
				$r = '|CHERRY-PICKING'
			}
			elseif (Test-Path $gitDir/REVERT_HEAD) {
				dbg 'Found REVERT_HEAD' $sw
				$r = '|REVERTING'
			}
			elseif (Test-Path $gitDir/BISECT_LOG) {
				dbg 'Found BISECT_LOG' $sw
				$r = '|BISECTING'
			}

			if ($step -and $total) {
				$r += " $step/$total"
			}

			$b = Invoke-NullCoalescing `
				$b `
				$branch `
				{ dbg 'Trying symbolic-ref' $sw; git --no-optional-locks symbolic-ref HEAD -q 2>$null } `
				{ '({0})' -f (Invoke-NullCoalescing `
					{
						dbg 'Trying describe' $sw
						switch ($Global:GitPromptSettings.DescribeStyle) {
							'contains' { git --no-optional-locks describe --contains HEAD 2>$null }
							'branch' { git --no-optional-locks describe --contains --all HEAD 2>$null }
							'describe' { git --no-optional-locks describe HEAD 2>$null }
							default { git --no-optional-locks tag --points-at HEAD 2>$null }
						}
					} `
					{
						dbg 'Falling back on parsing HEAD' $sw
						$ref = $null

						if (Test-Path $gitDir/HEAD) {
							dbg 'Reading from .git/HEAD' $sw
							$ref = Get-Content $gitDir/HEAD 2>$null
						}
						else {
							dbg 'Trying rev-parse' $sw
							$ref = git --no-optional-locks rev-parse HEAD 2>$null
						}

						if ($ref -match 'ref: (?<ref>.+)') {
							return $Matches['ref']
						}
						elseif ($ref -and $ref.Length -ge 7) {
							return $ref.Substring(0, 7) + '...'
						}
						else {
							return 'unknown'
						}
					}
				) }
		}

		if ($isDotGitOrBare -or !$b) {
			dbg 'Inside git directory?' $sw
			$revParseOut = git --no-optional-locks rev-parse --is-inside-git-dir 2>$null
			if ('true' -eq $revParseOut) {
				dbg 'Inside git directory' $sw
				$revParseOut = git --no-optional-locks rev-parse --is-bare-repository 2>$null
				if ('true' -eq $revParseOut) {
					$c = 'BARE:'
				}
				else {
					$b = 'GIT_DIR!'
				}
			}
		}

		"$c$($b -replace 'refs/heads/','')$r"
	}
}

function GetUniquePaths($pathCollections) {
	$hash = New-Object System.Collections.Specialized.OrderedDictionary

	foreach ($pathCollection in $pathCollections) {
		foreach ($path in $pathCollection) {
			$hash[$path] = 1
		}
	}

	$hash.Keys
}

$castStringSeq = [Linq.Enumerable].GetMethod("Cast").MakeGenericMethod([string])

<#
.SYNOPSIS
	Gets a Git status object that is used by `Write-GitStatus`.
.DESCRIPTION
	The `Get-GitStatus` cmdlet gets the status of the current Git repo.

	The status object returned by this cmdlet provides the information
	displayed in the various sections of the posh-git prompt. The following
	properties in $GitPromptSettings control what information is returned in
	the status object:

	EnableFileStatus		  = $true # Or $false if Git not installed
	EnableFileStatusFromCache = <unset> # Or $true if GitStatusCachePoshClient installed
	EnablePromptStatus		= $true
	EnableStashStatus		 = $false
	UntrackedFilesMode		= Default # Other enum values: No, Normal, All

	The `Force` parameter can be used to override the EnableFileStatus and
	EnablePromptStatus properties to ensure that both file and prompt status
	information is returned in the status object.
.EXAMPLE
	PS C:\> $s = Get-GitStatus; Write-GitStatus $s
	Gets a Git status object. Then passes the object to Write-GitStatus which
	writes out a posh-git prompt (or returns a string in ANSI mode) with the
	information contained in the status object.
.EXAMPLE
	PS C:\> $s = Get-GitStatus -Force
	Gets a Git status object that always returns all status information even
	if $GitPromptSettings has disabled `EnableFileStatus` and/or
	`EnablePromptStatus`.
.INPUTS
	None
.OUTPUTS
	System.Management.Automation.PSObject
.LINK
	Write-GitStatus
#>
function Get-GitStatus {
	param(
		# The path of a directory within a Git repository that you want to get
		# the Git status.
		[Parameter(Position = 0)]
		$GitDir = (Get-GitDirectory),

		# If specified, overrides $GitPromptSettings.EnableFileStatus and
		# $GitPromptSettings.EnablePromptStatus when they are set to $false.
		[Parameter()]
		[switch]
		$Force
	)

	$settings = if ($global:GitPromptSettings) { $global:GitPromptSettings } else { [PoshGitPromptSettings]::new() }

	$promptStatusEnabled = $Force -or $settings.EnablePromptStatus
	if ($promptStatusEnabled -and $GitDir) {
		if ($settings.Debug) {
			$sw = [Diagnostics.Stopwatch]::StartNew(); Write-Host ''
		}
		else {
			$sw = $null
		}

		$branch = $null
		$aheadBy = 0
		$behindBy = 0
		$gone = $false
		$upstream = $null

		$indexAdded = New-Object System.Collections.Generic.List[string]
		$indexModified = New-Object System.Collections.Generic.List[string]
		$indexDeleted = New-Object System.Collections.Generic.List[string]
		$indexUnmerged = New-Object System.Collections.Generic.List[string]
		$filesAdded = New-Object System.Collections.Generic.List[string]
		$filesModified = New-Object System.Collections.Generic.List[string]
		$filesDeleted = New-Object System.Collections.Generic.List[string]
		$filesUnmerged = New-Object System.Collections.Generic.List[string]
		$stashCount = 0

		$fileStatusEnabled = $Force -or $settings.EnableFileStatus
		# Optimization: short-circuit to avoid InDotGitOrBareRepoDir and InDisabledRepository if !$fileStatusEnabled
		if ($fileStatusEnabled -and !$($isDotGitOrBare = InDotGitOrBareRepoDir $GitDir) -and !$(InDisabledRepository)) {
			if ($null -eq $settings.EnableFileStatusFromCache) {
				$settings.EnableFileStatusFromCache = $null -ne (Get-Module GitStatusCachePoshClient)
			}

			if ($settings.EnableFileStatusFromCache) {
				dbg 'Getting status from cache' $sw
				$cacheResponse = Get-GitStatusFromCache

				if ($cacheResponse.Error) {
					# git-status-cache failed; set $global:GitStatusCacheLoggingEnabled = $true, call Restart-GitStatusCache,
					# and check %temp%\GitStatusCache_[timestamp].log for details.
					dbg "Cache returned an error: $($cacheResponse.Error)" $sw
					$branch = "CACHE ERROR"
					$behindBy = 1
				}
				else {
					dbg 'Parsing status' $sw

					$indexAdded.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.IndexAdded))))
					$indexModified.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.IndexModified))))
					foreach ($indexRenamed in $cacheResponse.IndexRenamed) {
						$indexModified.Add($indexRenamed.Old)
					}
					$indexDeleted.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.IndexDeleted))))
					$indexUnmerged.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.Conflicted))))

					$filesAdded.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.WorkingAdded))))
					$filesModified.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.WorkingModified))))
					foreach ($workingRenamed in $cacheResponse.WorkingRenamed) {
						$filesModified.Add($workingRenamed.Old)
					}
					$filesDeleted.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.WorkingDeleted))))
					$filesUnmerged.AddRange($castStringSeq.Invoke($null, (, @($cacheResponse.Conflicted))))

					$branch = $cacheResponse.Branch
					$upstream = $cacheResponse.Upstream
					$gone = $cacheResponse.UpstreamGone
					$aheadBy = $cacheResponse.AheadBy
					$behindBy = $cacheResponse.BehindBy

					if ($settings.EnableStashStatus -and $cacheResponse.Stashes) {
						$stashCount = $cacheResponse.Stashes.Length
					}

					if ($cacheResponse.State) {
						$branch += "|" + $cacheResponse.State
					}
				}
			}
			else {
				dbg 'Getting status' $sw
				switch ($settings.UntrackedFilesMode) {
					"No" { $untrackedFilesOption = "-uno" }
					"All" { $untrackedFilesOption = "-uall" }
					default { $untrackedFilesOption = "-unormal" }
				}
				$status = Invoke-Utf8ConsoleCommand { git --no-optional-locks '-c' core.quotepath=false '-c' color.status=false status $untrackedFilesOption --short --branch 2>$null }
				if ($settings.EnableStashStatus) {
					dbg 'Getting stash count' $sw
					$stashCount = $null | git --no-optional-locks stash list 2>$null | measure-object | Select-Object -expand Count
				}

				dbg 'Parsing status' $sw
				switch -regex ($status) {
					'^(?<index>[^#])(?<working>.) (?<path1>.*?)(?: -> (?<path2>.*))?$' {
						if ($sw) { dbg "Status: $_" $sw }

						$path1 = $matches['path1']

						# Even with core.quotePath=false, paths with spaces are wrapped in ""
						# https://github.com/git/git/commit/dbfdc625a5aad10c47e3ffa446d0b92e341a7b44
						# https://github.com/git/git/commit/f3fc4a1b8680c114defd98ce6f2429f8946a5dc1
						if ($path1 -like '"*"') {
							$path1 = $path1.Substring(1, $path1.Length - 2)
						}

						switch ($matches['index']) {
							'A' { $null = $indexAdded.Add($path1); break }
							'M' { $null = $indexModified.Add($path1); break }
							'R' { $null = $indexModified.Add($path1); break }
							'C' { $null = $indexModified.Add($path1); break }
							'D' { $null = $indexDeleted.Add($path1); break }
							'U' { $null = $indexUnmerged.Add($path1); break }
						}
						switch ($matches['working']) {
							'?' { $null = $filesAdded.Add($path1); break }
							'A' { $null = $filesAdded.Add($path1); break }
							'M' { $null = $filesModified.Add($path1); break }
							'D' { $null = $filesDeleted.Add($path1); break }
							'U' { $null = $filesUnmerged.Add($path1); break }
						}
						continue
					}

					'^## (?<branch>\S+?)(?:\.\.\.(?<upstream>\S+))?(?: \[(?:ahead (?<ahead>\d+))?(?:, )?(?:behind (?<behind>\d+))?(?<gone>gone)?\])?$' {
						if ($sw) { dbg "Status: $_" $sw }

						$branch = $matches['branch']
						$upstream = $matches['upstream']
						$aheadBy = [int]$matches['ahead']
						$behindBy = [int]$matches['behind']
						$gone = [string]$matches['gone'] -eq 'gone'
						continue
					}

					'^## Initial commit on (?<branch>\S+)$' {
						if ($sw) { dbg "Status: $_" $sw }

						$branch = $matches['branch']
						continue
					}

					default { if ($sw) { dbg "Status: $_" $sw } }
				}
			}
		}

		$branch = Get-GitBranch -Branch $branch -GitDir $GitDir -IsDotGitOrBare:$isDotGitOrBare -sw $sw

		dbg 'Building status object' $sw

		# This collection is used twice, so create the array just once
		$filesAdded = $filesAdded.ToArray()

		$indexPaths = @(GetUniquePaths $indexAdded, $indexModified, $indexDeleted, $indexUnmerged)
		$workingPaths = @(GetUniquePaths $filesAdded, $filesModified, $filesDeleted, $filesUnmerged)
		$index = (, $indexPaths) |
			Add-Member -Force -PassThru NoteProperty Added	$indexAdded.ToArray() |
			Add-Member -Force -PassThru NoteProperty Modified $indexModified.ToArray() |
			Add-Member -Force -PassThru NoteProperty Deleted  $indexDeleted.ToArray() |
			Add-Member -Force -PassThru NoteProperty Unmerged $indexUnmerged.ToArray()

		$working = (, $workingPaths) |
			Add-Member -Force -PassThru NoteProperty Added	$filesAdded |
			Add-Member -Force -PassThru NoteProperty Modified $filesModified.ToArray() |
			Add-Member -Force -PassThru NoteProperty Deleted  $filesDeleted.ToArray() |
			Add-Member -Force -PassThru NoteProperty Unmerged $filesUnmerged.ToArray()

		$result = New-Object PSObject -Property @{
			GitDir	   = $GitDir
			RepoName	 = Split-Path (Split-Path $GitDir -Parent) -Leaf
			Branch	   = $branch
			AheadBy	  = $aheadBy
			BehindBy	 = $behindBy
			UpstreamGone = $gone
			Upstream	 = $upstream
			HasIndex	 = [bool]$index
			Index		= $index
			HasWorking   = [bool]$working
			Working	  = $working
			HasUntracked = [bool]$filesAdded
			StashCount   = $stashCount
		}

		dbg 'Finished' $sw
		if ($sw) { $sw.Stop() }
		return $result
	}
}

function InDisabledRepository {
	$currentLocation = Get-Location

	foreach ($repo in $Global:GitPromptSettings.RepositoriesInWhichToDisableFileStatus) {
		if ($currentLocation -like "$repo*") {
			return $true
		}
	}

	return $false
}

function InDotGitOrBareRepoDir([string][ValidateNotNullOrEmpty()]$GitDir) {
	# A UNC path has no drive so it's better to use the ProviderPath e.g. "\\server\share".
	# However for any path with a drive defined, it's better to use the Path property.
	# In this case, ProviderPath is "\LocalMachine\My"" whereas Path is "Cert:\LocalMachine\My".
	# The latter is more desirable.
	$pathInfo = Microsoft.PowerShell.Management\Get-Location
	$currentPath = if ($pathInfo.Drive) { $pathInfo.Path } else { $pathInfo.ProviderPath }
	$separator = [System.IO.Path]::DirectorySeparatorChar
	$res = "$currentPath$separator".StartsWith("$GitDir$separator", (Get-PathStringComparison))
	$res
}

function Get-AliasPattern($cmd) {
	$aliases = @($cmd) + @(Get-Alias | Where-Object { $_.Definition -match "^$cmd(\.exe)?$" } | Foreach-Object Name)
	"($($aliases -join '|'))"
}

<#
.SYNOPSIS
	Deletes the specified Git branches.
.DESCRIPTION
	Deletes the specified Git branches that have been merged into the commit specified by the Commit parameter (HEAD by default). You must either specify a branch name via the Name parameter, which accepts wildard characters, or via the Pattern parameter, which accepts a regular expression.

	The following branches are always excluded from deletion:

	* The current branch
	* develop
	* master

	The default set of excluded branches can be overridden with the ExcludePattern parameter.

	Consider always running this command FIRST with the WhatIf parameter. This will show you which branches will be deleted. This gives you a chance to adjust your branch name wildcard pattern or regular expression if you are using the Pattern parameter.

	IMPORTANT: Be careful using this command. Even though by default this command deletes only merged branches, most, if not all, of your historical branches have been merged. But that doesn't mean you want to delete them. That is why this command excludes `develop` and `master` by default. But you may use different names e.g. `development` or have other historical branches you don't want to delete. In these cases, you can either:

	* Specify a narrower branch name wildcard such as "user/$env:USERNAME/*".
	* Specify an updated ExcludeParameter e.g. '(^\*)|(^. (develop|master|v\d+)$)' which adds any branch matching the pattern 'v\d+' to the exclusion list.

	If necessary, you can delete the specified branches REGARDLESS of their merge status by using the IncludeUnmerged parameter. BE VERY CAREFUL using the IncludeUnmerged parameter together with the Force parameter, since you will not be given the opportunity to confirm each branch deletion.

	The following Git commands are executed by this command:

		git branch --merged $Commit |
			Where-Object { $_ -notmatch $ExcludePattern } |
			Where-Object { $_.Trim() -like $Name } |
			Foreach-Object { git branch --delete $_.Trim() }

	If the IncludeUnmerged parameter is specified, execution changes to:

		git branch |
			Where-Object { $_ -notmatch $ExcludePattern } |
			Where-Object { $_.Trim() -like $Name } |
			Foreach-Object { git branch --delete $_.Trim() }

	If the DeleteForce parameter is specified, the Foreach-Object changes to:

		Foreach-Object { git branch --delete --force $_.Trim() }

	If the Pattern parameter is used instead of the Name parameter, the second Where-Object changes to:

		Where-Object { $_ -match $Pattern }

	Recovering Deleted Branches

	If you wind up deleting a branch you didn't intend to, you can easily recover it with the info provided by Git during the delete. For instance, let's say you realized you didn't want to delete the branch 'feature/exp1'. In the output of this command, you should see a deletion entry for this branch that looks like:

		Deleted branch feature/exp1 (was 08f9000).

	To recover this branch, execute the following Git command:

		# git branch <branch-name> <sha1>
		git branch feature/exp1 08f9000
.EXAMPLE
	PS> Remove-GitBranch -Name "user/${env:USERNAME}/*" -WhatIf
	Shows the merged branches that would be deleted by the specified branch name without actually deleting. Remove the WhatIf parameter when you are happy with the list of branches that will be deleted.
.EXAMPLE
	PS> Remove-GitBranch "feature/*" -Force
	Deletes the merged branches that match the specified wildcard. Using the Force parameter skips all confirmation prompts. Name is a positional parameter. The first argument is assumed to be the value of the Name parameter.
.EXAMPLE
	PS> Remove-GitBranch "bugfix/*" -Force -DeleteForce
	Deletes the merged branches that match the specified wildcard. Using the Force parameter skips all confirmation prompts while the DeleteForce parameter uses the --force option in the underlying Git command.
.EXAMPLE
	PS> Remove-GitBranch -Pattern 'user/(dahlbyk|hillr)/.*'
	Deletes the merged branches that match the specified regular expression.
.EXAMPLE
	PS> Remove-GitBranch -Name * -ExcludePattern '(^\*)|(^. (develop|master|v\d+)$)'
	Deletes merged branches except the current branch, develop, master and branches that also match the pattern 'v\d+' e.g. v1, v1.0, v1.x. BE VERY CAREFUL SPECIYING SUCH A BROAD BRANCH NAME WILDCARD!
.EXAMPLE
	PS> Remove-GitBranch "feature/*" -IncludeUnmerged -WhatIf
	Shows the branches, both merged and unmerged, that match the specified wildcard that would be deleted without actually deleting them. Once you've verified the list of branches looks correct, remove the WhatIf parameter to actually delete the branches.
#>
function Remove-GitBranch {
	[CmdletBinding(DefaultParameterSetName = "Wildcard", SupportsShouldProcess, ConfirmImpact = "Medium")]
	param(
		# Specifies a regular expression pattern for the branches that will be deleted. Certain branches are always excluded from deletion e.g. the current branch as well as the develop and master branches. See the ExcludePattern parameter to modify that pattern.
		[Parameter(Position = 0, Mandatory, ParameterSetName = "Wildcard")]
		[ValidateNotNullOrEmpty()]
		[string]
		$Name,

		# Specifies a regular expression for the branches that will be deleted. Certain branches are always excluded from deletion e.g. the current branch as well as the develop and master branches. See the ExcludePattern parameter to modify that pattern.
		[Parameter(Position = 0, Mandatory, ParameterSetName = "Pattern")]
		[ValidateNotNull()]
		[string]
		$Pattern,

		# Specifies a regular expression used to exclude merged branches from being deleted. The default pattern excludes the current branch, develop and master branches.
		[Parameter()]
		[ValidateNotNull()]
		[string]
		$ExcludePattern = '(^\*)|(^. (develop|master)$)',

		# Branches whose tips are reachable from the specified commit will be deleted. The default commit is HEAD. This parameter is ignored if the IncludeUnmerged parameter is specified.
		[Parameter()]
		[string]
		$Commit = "HEAD",

		# Specifies that unmerged branches are also eligible to be deleted.
		[Parameter()]
		[switch]
		$IncludeUnmerged,

		# Deletes the specified branches without prompting for confirmation. By default, Remove-GitBranch prompts for confirmation before deleting branches.
		[Parameter()]
		[switch]
		$Force,

		# Deletes the specified branches by adding the --force parameter to the git branch --delete command e.g. git branch --delete --force <branch-name>. This is also the equivalent of using the -D parameter on the git branch command.
		[Parameter()]
		[switch]
		$DeleteForce
	)

	if ($IncludeUnmerged) {
		$branches = git branch
	}
	else {
		$branches = git branch --merged $Commit
	}

	$filteredBranches = $branches | Where-Object { $_ -notmatch $ExcludePattern }

	if ($PSCmdlet.ParameterSetName -eq "Wildcard") {
		$branchesToDelete = $filteredBranches | Where-Object { $_.Trim() -like $Name }
	}
	else {
		$branchesToDelete = $filteredBranches | Where-Object { $_ -match $Pattern }
	}

	$action = if ($DeleteForce) { "delete with force" } else { "delete" }
	$yesToAll = $noToAll = $false

	foreach ($branch in $branchesToDelete) {
		$targetBranch = $branch.Trim()
		if ($PSCmdlet.ShouldProcess($targetBranch, $action)) {
			if ($Force -or $yesToAll -or
				$PSCmdlet.ShouldContinue(
					"Are you REALLY sure you want to $action `"$targetBranch`"?",
					"Confirm branch deletion", [ref]$yesToAll, [ref]$noToAll)) {

				if ($noToAll) { return }

				if ($DeleteForce) {
					Invoke-Utf8ConsoleCommand { git branch --delete --force $targetBranch }
				}
				else {
					Invoke-Utf8ConsoleCommand { git branch --delete $targetBranch }
				}
			}
		}
	}
}

function Update-AllBranches($Upstream = 'master', [switch]$Quiet) {
	$head = git rev-parse --abbrev-ref HEAD
	git checkout -q $Upstream
	$branches = Invoke-Utf8ConsoleCommand { (git branch --no-color --no-merged) } | Where-Object { $_ -notmatch '^\* ' }
	foreach ($line in $branches) {
		$branch = $line.SubString(2)
		if (!$Quiet) { Write-Host "Rebasing $branch onto $Upstream..." }

		git rebase -q $Upstream $branch > $null 2> $null
		if ($LASTEXITCODE) {
			git rebase --abort
			Write-Warning "Rebase failed for $branch"
		}
	}

	git checkout -q $head
}















# Initial implementation by Jeremy Skinner
# http://www.jeremyskinner.co.uk/2010/03/07/using-git-with-windows-powershell/

$Global:GitTabSettings = New-Object PSObject -Property @{
	AllCommands = $false
	KnownAliases = @{
		'!f() { exec vsts code pr "$@"; }; f' = 'vsts.pr'
	}
	EnableLogging = $false
	LogPath = Join-Path ([System.IO.Path]::GetTempPath()) posh-git_tabexp.log
	RegisteredCommands = ""
}

$subcommands = @{
	bisect = "start bad good skip reset visualize replay log run"
	notes = 'add append copy edit get-ref list merge prune remove show'
	'vsts.pr' = 'create update show list complete abandon reactivate reviewers work-items set-vote policies'
	reflog = "show delete expire"
	remote = "
		add rename remove set-head set-branches
		get-url set-url show prune update
		"
	rerere = "clear forget diff remaining status gc"
	stash = 'push save list show apply clear drop pop create branch'
	submodule = "add status init deinit update summary foreach sync"
	svn = "
		init fetch clone rebase dcommit log find-rev
		set-tree commit-diff info create-ignore propget
		proplist show-ignore show-externals branch tag blame
		migrate mkdirs reset gc
		"
	tfs = "
		list-remote-branches clone quick-clone bootstrap init
		clone fetch pull quick-clone unshelve shelve-list labels
		rcheckin checkin checkintool shelve shelve-delete
		branch
		info cleanup cleanup-workspaces help verify autotag subtree reset-remote checkout
		"
	flow = "init feature bugfix release hotfix support help version"
	worktree = "add list lock move prune remove unlock"
}

$gitflowsubcommands = @{
	init = 'help'
	feature = 'list start finish publish track diff rebase checkout pull help delete'
	bugfix = 'list start finish publish track diff rebase checkout pull help delete'
	release = 'list start finish track publish help delete'
	hotfix = 'list start finish track publish help delete'
	support = 'list start help'
	config = 'list set base'
}

function script:gitCmdOperations($commands, $command, $filter) {
	$commands[$command].Trim() -split '\s+' | Where-Object { $_ -like "$filter*" }
}

$script:someCommands = @(
	'add','am','annotate','archive','bisect','blame','branch','bundle','checkout','cherry',
	'cherry-pick','citool','clean','clone','commit','config','describe','diff','difftool','fetch',
	'format-patch','gc','grep','gui','help','init','instaweb','log','merge','mergetool','mv',
	'notes','prune','pull','push','rebase','reflog','remote','rerere','reset','restore','revert','rm',
	'shortlog','show','stash','status','submodule','svn','switch','tag','whatchanged', 'worktree'
)

if ((($PSVersionTable.PSVersion.Major -eq 5) -or $IsWindows) -and ($script:GitVersion -ge [System.Version]'2.16.2')) {
	$script:someCommands += 'update-git-for-windows'
}

$script:gitCommandsWithLongParams = $longGitParams.Keys -join '|'
$script:gitCommandsWithShortParams = $shortGitParams.Keys -join '|'
$script:gitCommandsWithParamValues = $gitParamValues.Keys -join '|'
$script:vstsCommandsWithShortParams = $shortVstsParams.Keys -join '|'
$script:vstsCommandsWithLongParams = $longVstsParams.Keys -join '|'

# The regular expression here is roughly follows this pattern:
#
# <begin anchor><whitespace>*<git>(<whitespace><parameter>)*<whitespace>+<$args><whitespace>*<end anchor>
#
# The delimiters inside the parameter list and between some of the elements are non-newline whitespace characters ([^\S\r\n]).
# In those instances, newlines are only allowed if they preceded by a non-newline whitespace character.
#
# Begin anchor (^|[;`n])
# Whitespace   (\s*)
# Git Command  (?<cmd>$(GetAliasPattern git))
# Parameters   (?<params>(([^\S\r\n]|[^\S\r\n]``\r?\n)+\S+)*)
# $args Anchor (([^\S\r\n]|[^\S\r\n]``\r?\n)+\`$args)
# Whitespace   (\s|``\r?\n)*
# End Anchor   ($|[|;`n])
$script:GitProxyFunctionRegex = "(^|[;`n])(\s*)(?<cmd>$(Get-AliasPattern git))(?<params>(([^\S\r\n]|[^\S\r\n]``\r?\n)+\S+)*)(([^\S\r\n]|[^\S\r\n]``\r?\n)+\`$args)(\s|``\r?\n)*($|[|;`n])"

try {
	if ($null -ne (git help -a 2>&1 | Select-String flow)) {
		$script:someCommands += 'flow'
	}
}
catch {
	Write-Debug "Search for 'flow' in 'git help' output failed with error: $_"
}

filter quoteStringWithSpecialChars {
	if ($_ -and ($_ -match '\s+|#|@|\$|;|,|''|\{|\}|\(|\)')) {
		$str = $_ -replace "'", "''"
		"'$str'"
	}
	else {
		$_
	}
}

function script:gitCommands($filter, $includeAliases) {
	$cmdList = @()
	if (-not $global:GitTabSettings.AllCommands) {
		$cmdList += $someCommands -like "$filter*"
	}
	else {
		$cmdList += git help --all |
			Where-Object { $_ -match '^\s{2,}\S.*' } |
			ForEach-Object { $_.Split(' ', [StringSplitOptions]::RemoveEmptyEntries) } |
			Where-Object { $_ -like "$filter*" }
	}

	if ($includeAliases) {
		$cmdList += gitAliases $filter
	}

	$cmdList | Sort-Object
}

function script:gitRemotes($filter) {
	git remote |
		Where-Object { $_ -like "$filter*" } |
		quoteStringWithSpecialChars
}

function script:gitBranches($filter, $includeHEAD = $false, $prefix = '') {
	if ($filter -match "^(?<from>\S*\.{2,3})(?<to>.*)") {
		$prefix += $matches['from']
		$filter = $matches['to']
	}

	$branches = @(git branch --no-color | ForEach-Object { if (($_ -notmatch "^\* \(HEAD detached .+\)$") -and ($_ -match "^[\*\+]?\s*(?<ref>\S+)(?: -> .+)?")) { $matches['ref'] } }) +
				@(git branch --no-color -r | ForEach-Object { if ($_ -match "^  (?<ref>\S+)(?: -> .+)?") { $matches['ref'] } }) +
				@(if ($includeHEAD) { 'HEAD','FETCH_HEAD','ORIG_HEAD','MERGE_HEAD' })

	$branches |
		Where-Object { $_ -ne '(no branch)' -and $_ -like "$filter*" } |
		ForEach-Object { $prefix + $_ } |
		quoteStringWithSpecialChars
}

function script:gitRemoteUniqueBranches($filter) {
	git branch --no-color -r |
		ForEach-Object { if ($_ -match "^  (?<remote>[^/]+)/(?<branch>\S+)(?! -> .+)?$") { $matches['branch'] } } |
		Group-Object -NoElement |
		Where-Object { $_.Count -eq 1 } |
		Select-Object -ExpandProperty Name |
		Where-Object { $_ -like "$filter*" } |
		quoteStringWithSpecialChars
}

function script:gitConfigKeys($section, $filter, $defaultOptions = '') {
	$completions = @($defaultOptions -split ' ')

	git config --name-only --get-regexp ^$section\..* |
		ForEach-Object { $completions += ($_ -replace "$section\.","") }

	return $completions |
		Where-Object { $_ -like "$filter*" } |
		Sort-Object |
		quoteStringWithSpecialChars
}

function script:gitTags($filter, $prefix = '') {
	git tag |
		Where-Object { $_ -like "$filter*" } |
		ForEach-Object { $prefix + $_ } |
		quoteStringWithSpecialChars
}

function script:gitFeatures($filter, $command) {
	$featurePrefix = git config --local --get "gitflow.prefix.$command"
	$branches = @(git branch --no-color | ForEach-Object { if ($_ -match "^\*?\s*$featurePrefix(?<ref>.*)") { $matches['ref'] } })
	$branches |
		Where-Object { $_ -ne '(no branch)' -and $_ -like "$filter*" } |
		ForEach-Object { $featurePrefix + $_ } |
		quoteStringWithSpecialChars
}

function script:gitRemoteBranches($remote, $ref, $filter, $prefix = '') {
	git branch --no-color -r |
		Where-Object { $_ -like "  $remote/$filter*" } |
		ForEach-Object { $prefix + $ref + ($_ -replace "  $remote/","") } |
		quoteStringWithSpecialChars
}

function script:gitStashes($filter) {
	(git stash list) -replace ':.*','' |
		Where-Object { $_ -like "$filter*" } |
		quoteStringWithSpecialChars
}

function script:gitTfsShelvesets($filter) {
	(git tfs shelve-list) |
		Where-Object { $_ -like "$filter*" } |
		quoteStringWithSpecialChars
}

function script:gitFiles($filter, $files) {
	$files | Sort-Object |
		Where-Object { $_ -like "$filter*" } |
		quoteStringWithSpecialChars
}

function script:gitIndex($GitStatus, $filter) {
	gitFiles $filter $GitStatus.Index
}

function script:gitAddFiles($GitStatus, $filter) {
	gitFiles $filter (@($GitStatus.Working.Unmerged) + @($GitStatus.Working.Modified) + @($GitStatus.Working.Added))
}

function script:gitCheckoutFiles($GitStatus, $filter) {
	gitFiles $filter (@($GitStatus.Working.Unmerged) + @($GitStatus.Working.Modified) + @($GitStatus.Working.Deleted))
}

function script:gitDeleted($GitStatus, $filter) {
	gitFiles $filter $GitStatus.Working.Deleted
}

function script:gitDiffFiles($GitStatus, $filter, $staged) {
	if ($staged) {
		gitFiles $filter $GitStatus.Index.Modified
	}
	else {
		gitFiles $filter (@($GitStatus.Working.Unmerged) + @($GitStatus.Working.Modified) + @($GitStatus.Index.Modified))
	}
}

function script:gitMergeFiles($GitStatus, $filter) {
	gitFiles $filter $GitStatus.Working.Unmerged
}

function script:gitRestoreFiles($GitStatus, $filter, $staged) {
	if ($staged) {
		gitFiles $filter (@($GitStatus.Index.Added) + @($GitStatus.Index.Modified) + @($GitStatus.Index.Deleted))
	}
	else {
		gitFiles $filter (@($GitStatus.Working.Unmerged) + @($GitStatus.Working.Modified) + @($GitStatus.Working.Deleted))
	}
}

function script:gitAliases($filter) {
	git config --get-regexp ^alias\. | ForEach-Object{
		if ($_ -match "^alias\.(?<alias>\S+) .*") {
			$alias = $Matches['alias']
			if ($alias -like "$filter*") {
				$alias
			}
		}
	} | Sort-Object -Unique
}

function script:expandGitAlias($cmd, $rest) {
	$alias = git config "alias.$cmd"

	if ($alias) {
		$known = $Global:GitTabSettings.KnownAliases[$alias]
		if ($known) {
			return "git $known$rest"
		}

		return "git $alias$rest"
	}
	else {
		return "git $cmd$rest"
	}
}

function script:expandLongParams($hash, $cmd, $filter) {
	$hash[$cmd].Trim() -split ' ' |
		Where-Object { $_ -like "$filter*" } |
		Sort-Object |
		ForEach-Object { -join ("--", $_) }
}

function script:expandShortParams($hash, $cmd, $filter) {
	$hash[$cmd].Trim() -split ' ' |
		Where-Object { $_ -like "$filter*" } |
		Sort-Object |
		ForEach-Object { -join ("-", $_) }
}

function script:expandParamValues($cmd, $param, $filter) {
	$paramValues = $gitParamValues[$cmd][$param]

	$completions = if ($paramValues -is [scriptblock]) {
		& $paramValues $filter
	}
	else {
		$paramValues.Trim() -split ' ' | Where-Object { $_ -like "$filter*" } | Sort-Object
	}

	$completions | ForEach-Object { -join ("--", $param, "=", $_) }
}

function Expand-GitCommand($Command) {
	# Parse all Git output as UTF8, including tab completion output - https://github.com/dahlbyk/posh-git/pull/359
	$res = GitTabExpansionInternal $Command $Global:GitStatus
	$res
}

function GitTabExpansionInternal($lastBlock, $GitStatus = $null) {
	$ignoreGitParams = '(?<params>\s+-(?:[aA-zZ0-9]+|-[aA-zZ0-9][aA-zZ0-9-]*)(?:=\S+)?)*'

	if ($lastBlock -match "^$(Get-AliasPattern git) (?<cmd>\S+)(?<args> .*)$") {
		$lastBlock = expandGitAlias $Matches['cmd'] $Matches['args']
	}

	# Handles tgit <command> (tortoisegit)
	if ($lastBlock -match "^$(Get-AliasPattern tgit) (?<cmd>\S*)$") {
		# Need return statement to prevent fall-through.
		return $Global:TortoiseGitSettings.TortoiseGitCommands.Keys.GetEnumerator() | Sort-Object | Where-Object { $_ -like "$($matches['cmd'])*" }
	}

	# Handles gitk
	if ($lastBlock -match "^$(Get-AliasPattern gitk).* (?<ref>\S*)$") {
		return gitBranches $matches['ref'] $true
	}

	switch -regex ($lastBlock -replace "^$(Get-AliasPattern git) ","") {

		# Handles git <cmd> <op>
		"^(?<cmd>$($subcommands.Keys -join '|'))\s+(?<op>\S*)$" {
			gitCmdOperations $subcommands $matches['cmd'] $matches['op']
		}

		# Handles git flow <cmd> <op>
		"^flow (?<cmd>$($gitflowsubcommands.Keys -join '|'))\s+(?<op>\S*)$" {
			gitCmdOperations $gitflowsubcommands $matches['cmd'] $matches['op']
		}

		# Handles git flow <command> <op> <name>
		"^flow (?<command>\S*)\s+(?<op>\S*)\s+(?<name>\S*)$" {
			gitFeatures $matches['name'] $matches['command']
		}

		# Handles git remote (rename|rm|remove|set-head|set-branches|set-url|show|prune) <stash>
		"^remote.* (?:rename|rm|remove|set-head|set-branches|set-url|show|prune).* (?<remote>\S*)$" {
			gitRemotes $matches['remote'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "remote $_") }
		}

		# Handles git stash (show|apply|drop|pop|branch) <stash>
		"^stash (?:show|apply|drop|pop|branch).* (?<stash>\S*)$" {
			gitStashes $matches['stash'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "stash $_") }
		}

		# Handles git bisect (bad|good|reset|skip) <ref>
		"^bisect (?:bad|good|reset|skip).* (?<ref>\S*)$" {
			gitBranches $matches['ref'] $true |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "branch $_") }
		}

		# Handles git tfs unshelve <shelveset>
		"^tfs +unshelve.* (?<shelveset>\S*)$" {
			gitTfsShelvesets $matches['shelveset']
		}

		# Handles git branch -d|-D|-m|-M <branch name>
		# Handles git branch <branch name> <start-point>
		"^branch.* (?<branch>\S*)$" {
			gitBranches $matches['branch']
		}

		# Handles git <cmd> (commands & aliases)
		"^(?<cmd>\S*)$" {
			gitCommands $matches['cmd'] $TRUE
		}

		# Handles git help <cmd> (commands only)
		"^help (?<cmd>\S*)$" {
			gitCommands $matches['cmd'] $FALSE
		}

		# Handles git push remote <ref>:<branch>
		# Handles git push remote +<ref>:<branch>
		"^push${ignoreGitParams}\s+(?<remote>[^\s-]\S*).*\s+(?<force>\+?)(?<ref>[^\s\:]*\:)(?<branch>\S*)$" {
			gitRemoteBranches $matches['remote'] $matches['ref'] $matches['branch'] -prefix $matches['force'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "branch $_") }
		}

		# Handles git push remote <ref>
		# Handles git push remote +<ref>
		# Handles git pull remote <ref>
		"^(?:push|pull)${ignoreGitParams}\s+(?<remote>[^\s-]\S*).*\s+(?<force>\+?)(?<ref>[^\s\:]*)$" {
			gitBranches $matches['ref'] -prefix $matches['force'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "branch $_") }
			gitTags $matches['ref'] -prefix $matches['force'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "tag $_") }
		}

		# Handles git pull <remote>
		# Handles git push <remote>
		# Handles git fetch <remote>
		"^(?:push|pull|fetch)${ignoreGitParams}\s+(?<remote>\S*)$" {
			gitRemotes $matches['remote'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "remote $_") }
		}

		# Handles git reset HEAD <path>
		# Handles git reset HEAD -- <path>
		"^reset.* HEAD(?:\s+--)? (?<path>\S*)$" {
			gitIndex $GitStatus $matches['path']
		}

		# Handles git <cmd> <ref>
		"^commit.*-C\s+(?<ref>\S*)$" {
			gitBranches $matches['ref'] $true |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "branch $_") }
		}

		# Handles git add <path>
		"^add.* (?<files>\S*)$" {
			gitAddFiles $GitStatus $matches['files']
		}

		# Handles git checkout -- <path>
		"^checkout.* -- (?<files>\S*)$" {
			gitCheckoutFiles $GitStatus $matches['files']
		}

		# Handles git restore -s <ref> / --source=<ref> - must come before the next regex case
		"^restore.* (?-i)(-s\s*|(?<source>--source=))(?<ref>\S*)$" {
			gitBranches $matches['ref'] $true $matches['source']
			gitTags $matches['ref']
			break
		}

		# Handles git restore <path>
		"^restore(?:.* (?<staged>(?:(?-i)-S|--staged))|.*) (?<files>\S*)$" {
			gitRestoreFiles $GitStatus $matches['files'] $matches['staged']
		}

		# Handles git rm <path>
		"^rm.* (?<index>\S*)$" {
			gitDeleted $GitStatus $matches['index']
		}

		# Handles git diff/difftool <path>
		"^(?:diff|difftool)(?:.* (?<staged>(?:--cached|--staged))|.*) (?<files>\S*)$" {
			gitDiffFiles $GitStatus $matches['files'] $matches['staged']
		}

		# Handles git merge/mergetool <path>
		"^(?:merge|mergetool).* (?<files>\S*)$" {
			gitMergeFiles $GitStatus $matches['files']
		}

		# Handles git checkout|switch <ref>
		"^(?:checkout|switch).* (?<ref>\S*)$" {
			& {
				& {
					gitBranches $matches['ref'] $true
					gitRemoteUniqueBranches $matches['ref']
					# Return only unique branches (to eliminate duplicates where the branch exists locally and on the remote)
				} | Select-Object -Unique |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "branch $_") }

				gitTags $matches['ref'] | Select-Object -Unique |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "tag $_") }
			}
		}

		# Handles git worktree add <path> <ref>
		"^worktree add.* (?<files>\S+) (?<ref>\S*)$" {
			gitBranches $matches['ref'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "branch $_") }
		}

		# Handles git <cmd> <ref>
		"^(?:cherry|cherry-pick|diff|difftool|log|merge|rebase|reflog\s+show|reset|revert|show).* (?<ref>\S*)$" {
			gitBranches $matches['ref'] $true |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "branch $_") }
			gitTags $matches['ref'] |
				ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'DynamicKeyword', "tag $_") }
		}

		# Handles git <cmd> --<param>=<value>
		"^(?<cmd>$gitCommandsWithParamValues).* --(?<param>[^=]+)=(?<value>\S*)$" {
			expandParamValues $matches['cmd'] $matches['param'] $matches['value']
		}

		# Handles git <cmd> --<param>
		"^(?<cmd>$gitCommandsWithLongParams).* --(?<param>\S*)$" {
			expandLongParams $longGitParams $matches['cmd'] $matches['param']
		}

		# Handles git <cmd> -<shortparam>
		"^(?<cmd>$gitCommandsWithShortParams).* -(?<shortparam>\S*)$" {
			expandShortParams $shortGitParams $matches['cmd'] $matches['shortparam']
		}

		# Handles git pr alias
		"vsts\.pr\s+(?<op>\S*)$" {
			gitCmdOperations $subcommands 'vsts.pr' $matches['op']
		}

		# Handles git pr <cmd> --<param>
		"vsts\.pr\s+(?<cmd>$vstsCommandsWithLongParams).*--(?<param>\S*)$"
		{
			expandLongParams $longVstsParams $matches['cmd'] $matches['param']
		}

		# Handles git pr <cmd> -<shortparam>
		"vsts\.pr\s+(?<cmd>$vstsCommandsWithShortParams).*-(?<shortparam>\S*)$"
		{
			expandShortParams $shortVstsParams $matches['cmd'] $matches['shortparam']
		}
	}
}

function Expand-GitProxyFunction($command) {
	# Make sure the incoming command matches: <Command> <Args>, so we can extract the alias/command
	# name and the arguments being passed in.
	if ($command -notmatch '^(?<command>\S+)([^\S\r\n]|[^\S\r\n]`\r?\n)+(?<args>([^\S\r\n]|[^\S\r\n]`\r?\n|\S)*)$') {
		return $command
	}

	# Store arguments for replacement later
	$arguments = $matches['args']

	# Get the command name; if an alias exists, get the actual command name
	$commandName = $matches['command']
	if (Test-Path -Path Alias:\$commandName) {
		$commandName = Get-Item -Path Alias:\$commandName | Select-Object -ExpandProperty 'ResolvedCommandName'
	}

	# Extract definition of git usage
	if (Test-Path -Path Function:\$commandName) {
		$definition = Get-Item -Path Function:\$commandName | Select-Object -ExpandProperty 'Definition'
		if ($definition -match $script:GitProxyFunctionRegex) {
			# Clean up the command by removing extra delimiting whitespace and backtick preceding newlines
			return (("$($matches['cmd'].TrimStart()) $($matches['params']) $arguments") -replace '`\r?\n', ' ' -replace '\s+', ' ')
		}
	}

	return $command
}

function WriteTabExpLog([string] $Message) {
	if (!$global:GitTabSettings.EnableLogging) { return }

	$timestamp = Get-Date -Format HH:mm:ss
	"[$timestamp] $Message" | Out-File -Append $global:GitTabSettings.LogPath
}

if (!$UseLegacyTabExpansion -and ($PSVersionTable.PSVersion.Major -ge 6)) {
	$cmdNames = "git","tgit","gitk"

	# Create regex pattern from $cmdNames: ^(git|git\.exe|tgit|tgit\.exe|gitk|gitk\.exe)$
	$cmdNamesPattern = "^($($cmdNames -join '|'))(\.exe)?$"
	$cmdNames += Get-Alias | Where-Object { $_.Definition -match $cmdNamesPattern } | Foreach-Object Name

	if ($EnableProxyFunctionExpansion) {
		$funcNames += Get-ChildItem -Path Function:\ | Where-Object { $_.Definition -match $script:GitProxyFunctionRegex } | Foreach-Object Name
		$cmdNames += $funcNames

		# Create regex pattern from $funcNames e.g.: ^(Git-Checkout|Git-Switch)$
		$funcNamesPattern = "^($($funcNames -join '|'))$"
		$cmdNames += Get-Alias | Where-Object { $_.Definition -match $funcNamesPattern } | Foreach-Object Name
	}

	$global:GitTabSettings.RegisteredCommands = $cmdNames -join ", "

	Microsoft.PowerShell.Core\Register-ArgumentCompleter -CommandName $cmdNames -Native -ScriptBlock {
		param($wordToComplete, $commandAst, $cursorPosition)

		# The PowerShell completion has a habit of stripping the trailing space when completing:
		# git checkout <tab>
		# The Expand-GitCommand expects this trailing space, so pad with a space if necessary.
		$padLength = $cursorPosition - $commandAst.Extent.StartOffset
		$textToComplete = $commandAst.ToString().PadRight($padLength, ' ').Substring(0, $padLength)
		if ($EnableProxyFunctionExpansion) {
			$textToComplete = Expand-GitProxyFunction($textToComplete)
		}

		WriteTabExpLog "Expand: command: '$($commandAst.Extent.Text)', padded: '$textToComplete', padlen: $padLength"
		Expand-GitCommand $textToComplete
	}
}
else {
	$PowerTab_RegisterTabExpansion = if (Get-Module -Name powertab) { Get-Command Register-TabExpansion -Module powertab -ErrorAction SilentlyContinue }
	if ($PowerTab_RegisterTabExpansion) {
		& $PowerTab_RegisterTabExpansion git -Type Command {
			param($Context, [ref]$TabExpansionHasOutput, [ref]$QuoteSpaces)

			$line = $Context.Line
			$lastBlock = [regex]::Split($line, '[|;]')[-1].TrimStart()
			if ($EnableProxyFunctionExpansion) {
				$lastBlock = Expand-GitProxyFunction($lastBlock)
			}
			$TabExpansionHasOutput.Value = $true
			WriteTabExpLog "PowerTab expand: '$lastBlock'"
			Expand-GitCommand $lastBlock
		}

		return
	}

	function TabExpansion($line, $lastWord) {
		$lastBlock = [regex]::Split($line, '[|;]')[-1].TrimStart()
		if ($EnableProxyFunctionExpansion) {
			$lastBlock = Expand-GitProxyFunction($lastBlock)
		}
		$msg = "Legacy expand: '$lastBlock'"

		switch -regex ($lastBlock) {
			# Execute git tab completion for all git-related commands
			"^$(Get-AliasPattern git) (.*)"  { WriteTabExpLog $msg; Expand-GitCommand $lastBlock }
			"^$(Get-AliasPattern tgit) (.*)" { WriteTabExpLog $msg; Expand-GitCommand $lastBlock }
			"^$(Get-AliasPattern gitk) (.*)" { WriteTabExpLog $msg; Expand-GitCommand $lastBlock }
		}
	}
}

# Handles Remove-GitBranch -Name parameter auto-completion using the built-in mechanism for cmdlet parameters
Microsoft.PowerShell.Core\Register-ArgumentCompleter -CommandName Remove-GitBranch -ParameterName Name -ScriptBlock {
	param($Command, $Parameter, $WordToComplete, $CommandAst, $FakeBoundParams)

	gitBranches $WordToComplete $true
}



